<!DOCTYPE html>
<html lang="zh">

<head>
    <title>fabric test</title>
    <meta charset="utf-8" />
    <meta name="format-detection" content="telephone=no" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <script src="node_modules/fabricjs/index.js"></script>
    <script src="src/index.js"></script>

    <style>
        .canvas {
            width: 480px;
            height: 480px;
            box-shadow: 0 0 1rem rgba(0, 0, 0, .4);
            margin: 1.5rem auto;
            display: block;
        }
    </style>
</head>

<body>
    <canvas class="stage_stage canvas"></canvas>
    <canvas class="stage_stage1 canvas"></canvas>

    <!-- <section>
        <button data-action=""></button>
    </section> -->
    <script>

        const stage = document.querySelector(".stage_stage");
        const stage1 = document.querySelector(".stage_stage1");

        const cw = stage.clientWidth;
        const ch = stage.clientHeight;

        const ow = cw;
        const oh = ch;
        const lineWidth = 1;
        const offset = lineWidth / 2;
        const centerPoint = [ow / 2, oh / 2];
        const lineAttrs = {
            stroke: 'rgba(255, 0, 0, .85)',
            strokeWidth: lineWidth
        };

        const stageCanvas = new fabric.StaticCanvas(stage, {
            width: cw,
            height: ch
        });
        const stageCanvas1 = new fabric.StaticCanvas(stage1, {
            width: cw,
            height: ch
        });

        const ca = new CoordianteAxis();
        ca.cellSize = 50;
        ca.circleRadius = 3;
        const lines = ca.gridLines;
        stageCanvas.add(...lines);
        console.log(ca)
        console.log(ca.gridPoints)
        stageCanvas.add(ca.arrowLeft);
        stageCanvas.add(ca.arrowRight);
        stageCanvas.add(ca.arrowTop);
        stageCanvas.add(ca.arrowBottom);
        stageCanvas.add(ca.coordinateOrigin);


        const ca1 = new CoordianteAxis();
        ca1.cellSize = 50;
        ca1.originPosition = 'tl';
        const lines1 = ca1.gridLines;
        stageCanvas1.add(...lines1);
        // stageCanvas1.add(ca1.arrowLeft);
        stageCanvas1.add(ca1.arrowRight);
        // stageCanvas1.add(ca1.arrowTop);
        stageCanvas1.add(ca1.arrowBottom);

        console.log({ lines, lines1 });

        // 垂直：horizontal
        // 水平：vertical
        const newLine = (points, opts, direction = 'horizontal') => {
            for (let idx = 0; idx < points.length; idx++) {
                if (direction === 'horizontal') {
                    // 向上偏移
                    if (idx === 1 || idx === 3) {
                        points[idx] = points[idx] - offset;
                    }
                }

                if (direction === 'vertical') {
                    // 向左偏移
                    if (idx === 0 || idx === 2) {
                        points[idx] = points[idx] - offset;
                    }
                }
                // points[idx] = Math.round(points[idx]);
            }
            const line = new fabric.Line(points, {
                ...lineAttrs, ...opts
            });
            return line;
        };

        const coordinateOrigin = (centerPoint) => {
            // 中心位置坐标（坐标系，左上角为(0,0) ）
            const [x, y] = centerPoint;
            // 半径
            const r = 2;
            return new fabric.Circle({
                radius: r,
                top: y - r - offset,
                left: x - r - offset,
                fill: 'rgba(0, 0, 0, .8)',
                strokeWidth: lineWidth
            });
        }

        const grid = (centerPoint) => {
            const cellsize = 50;
            const [x, y] = centerPoint;
            const xlen = Math.floor(x / cellsize);
            const ylen = Math.floor(y / cellsize);
            const lines = [];
            const xtextPoints = [];
            const ytextPoints = [];
            const linePoints = [];

            for (let idx = 0; idx < xlen; idx++) {
                const offset = cellsize * (idx + 1);
                if (idx === 0) {
                    linePoints.push([
                        x,
                        0,
                        x,
                        y * 2
                    ]);
                }
                linePoints.push([
                    x + offset,
                    0,
                    x + offset,
                    y * 2
                ]);
                linePoints.push([
                    x - offset,
                    0,
                    x - offset,
                    y * 2
                ]);
                xtextPoints.push([x + offset, y]);
                xtextPoints.push([x - offset, y]);
            }

            for (let idx = 0; idx < ylen; idx++) {
                if (idx === 0) {
                    linePoints.push([
                        0,
                        y,
                        x * 2,
                        y
                    ]);
                }
                const offset = cellsize * (idx + 1);
                linePoints.push([
                    0,
                    y + offset,
                    x * 2,
                    y + offset
                ]);
                linePoints.push([
                    0,
                    y - offset,
                    x * 2,
                    y - offset
                ]);

                ytextPoints.push([x, y + offset]);
                ytextPoints.push([x, y - offset]);
            }

            for (let idx = 0; idx < linePoints.length; idx++) {
                const line = newLine(linePoints[idx], {
                    stroke: 'rgba(0, 0, 0, .125)'
                }, idx < xlen * 2 ? 'vertical' : 'horizontal');
                lines.push(line)
            }

            for (let idx = 0; idx < xtextPoints.length; idx++) {
                const point = xtextPoints[idx];
                const [x, y] = point;
                const [cx, cy] = centerPoint;
                const text = new fabric.Text(`${x - cx}`, {
                    top: y,
                    left: x,
                    fontSize: 12,
                    lineHeight: 1,
                    fill: 'rgba(255, 0, 0, .5)',
                    originX: 'right',
                    angle: -45
                });
                text.left = text.left - text.height / Math.sqrt(2);
                lines.push(text);
            }

            for (let idx = 0; idx < ytextPoints.length; idx++) {
                const point = ytextPoints[idx];
                const [x, y] = point;
                const [cx, cy] = centerPoint;
                const text = new fabric.Text(`${cy - y}`, {
                    top: y,
                    left: x,
                    fontSize: 12,
                    lineHeight: 1,
                    fill: 'rgba(255, 0, 0, .5)',
                    originX: 'right',
                    angle: -45
                });
                text.left = text.left - text.height / Math.sqrt(2);
                lines.push(text);
            }
            console.log(lines)
            return lines;
        };

        const arrow = (point, xAxis = true, dir = '') => {
            // 偏移位置
            const offset = 0.5;
            // 宽度
            let w = 8;
            // 高度
            let h = w / Math.sqrt(3);
            // 属性
            const attrs = {
                // 填充颜色
                fill: 'rgba(255, 0, 0, .85)'
            };
            const [x, y] = point;
            if (!xAxis) {
                const tempW = w;
                w = h;
                h = tempW;
            }
            if (dir === 'xr') {
                w = -w;
            }
            if (dir === 'yb') {
                h = -h;
            }
            const p1 = {
                x: xAxis ? x - offset : x,
                y: y - offset
            };
            const p3 = {
                x: xAxis ? p1.x + w * 0.5 : p1.x,
                y: xAxis ? p1.y : p1.y + h * 0.5
            };
            const p2 = {
                x: xAxis ? x + w : x - w,
                y: xAxis ? y - h : y + h
            };
            const p4 = {
                x: xAxis ? p2.x : x + w,
                y: xAxis ? y + h : p2.y
            };
            const points = [p1, p2, p3, p4];
            const arrow = new fabric.Polygon(points, attrs);
            return arrow;
        }

        const calibration = () => {
            const lines = [];
            const points = [];
            // 刻度大小
            const size = 5;
            const [x, y] = centerPoint;
            const xlen = Math.floor(x / size);
            const ylen = Math.floor(y / size);
            for (let idx = 0; idx < xlen; idx++) {
                const offset = size * idx;
                const d = idx % 5 === 0;
                points.push([
                    x + offset,
                    y,
                    x + offset,
                    y - (d ? size * 1.5 : size)
                ]);
                points.push([
                    x - offset,
                    y,
                    x - offset,
                    y - (d ? size * 1.5 : size)
                ]);
            }

            for (let idx = 0; idx < ylen; idx++) {
                const offset = size * idx;
                const d = idx % 5 === 0;
                points.push([
                    x,
                    y - offset,
                    x + (d ? size * 1.5 : size),
                    y - offset
                ]);
                points.push([
                    x,
                    y + offset,
                    x + (d ? size * 1.5 : size),
                    y + offset
                ]);
            }

            for (let idx = 0; idx < points.length; idx++) {
                const line = newLine(points[idx], {
                    stroke: 'rgba(255, 0, 0, .5)'
                }, idx < xlen * 2 ? 'vertical' : 'horizontal');
                lines.push(line);
            }

            return lines;
            // for (let idx = 0; idx < ylen; idx++) {
            //     if (idx === 0) {
            //         points.push([
            //             0,
            //             y,
            //             x * 2,
            //             y
            //         ]);
            //     }
            //     const offset = cellsize * (idx + 1);
            //     points.push([
            //         0,
            //         y + offset,
            //         x * 2,
            //         y + offset
            //     ]);
            //     points.push([
            //         0,
            //         y - offset,
            //         x * 2,
            //         y - offset
            //     ]);
            // }

        };

        const xAxisPoints = [0, ch / 2, cw, ch / 2];
        const yAxisPoints = [cw / 2, 0, cw / 2, ch];

        const xAxisLine = newLine(xAxisPoints);
        const yAxisLine = newLine(yAxisPoints, lineAttrs, 'vertical');

        const xArrow = () => {
            const { x1, y1, x2, y2 } = xAxisLine;
            const arrowLeft = arrow([x1, y1 + offset]);
            const arrowRight = arrow([x2, y2 + offset], true, 'xr');
            return [arrowLeft, arrowRight];
        };

        const [arrowLeft, arrowRight] = xArrow();

        const yArrow = () => {
            const { x1, y1, x2, y2 } = yAxisLine;
            const arrowUp = arrow([x1, y1], false);
            const arrowDown = arrow([x2, y2], false, 'yb');

            return [arrowUp, arrowDown];
        };

        const [arrowUp, arrowDown] = yArrow();

        xAxisLine.set({
            x1: xAxisLine.x1 + 4,
            x2: xAxisLine.x2 - 4,
        });

        yAxisLine.set({
            y1: yAxisLine.y1 + 4,
            y2: yAxisLine.y2 - 4,
        });


        // stageCanvas.add(...calibration());
        // stageCanvas.add(...grid(centerPoint));
        // stageCanvas1.add(...grid(centerPoint));
        // stageCanvas.add(xAxisLine);
        // stageCanvas.add(yAxisLine);
        // stageCanvas.add(arrowLeft);
        // stageCanvas.add(arrowRight);
        // stageCanvas.add(arrowUp);
        // stageCanvas.add(arrowDown);
        // stageCanvas.add(coordinateOrigin(centerPoint));
        // stageCanvas1.add(coordinateOrigin(centerPoint));


        const axisX = () => {
            const [x1, y1, x2, y2] = xAxisPoints;
            // // 箭头长度
            // const al = 8 * lineWidth;
            // // 高度
            // const h = al / Math.sqrt(3);
            // const arrowLeftPoints = (up = true) => {
            //     return [
            //         0 + al,
            //         up ? y2 - h : y2 + h,
            //         0 - offset,
            //         y2
            //     ]
            // };
            // const arrowRigthPoints = (up = true) => {
            //     return [
            //         x2 - al,
            //         up ? y2 - h : y2 + h,
            //         x2 - offset,
            //         y2
            //     ]
            // };
            // const upl = arrowLeftPoints(true);
            // const downl = arrowLeftPoints(false);
            // const upr = arrowRigthPoints(true);
            // const downr = arrowRigthPoints(false);
            // const arrowLeft = new fabric.Polygon([
            //     {
            //         x: x1 - offset,
            //         y: y1 - offset
            //     },
            //     {
            //         x: x1 + al,
            //         y: y1 - h
            //     },
            //     {
            //         x: x1 + al * 0.5,
            //         y: y1 - offset
            //     },
            //     {
            //         x: x1 + al,
            //         y: y1 + h
            //     }
            // ],
            //     {
            //         fill: 'rgba(255, 0, 0, .85)',
            //     }
            // );
            // const arrowRight = new fabric.Polygon([
            //     {
            //         x: x2 - offset,
            //         y: y2 - offset
            //     },
            //     {
            //         x: x2 - al,
            //         y: y2 - h
            //     },
            //     {
            //         x: x2 - al * 0.5,
            //         y: y2 - offset
            //     },
            //     {
            //         x: x2 - al,
            //         y: y2 + h
            //     }
            // ],
            //     {
            //         fill: 'rgba(255, 0, 0, .85)',
            //     }
            // );
            const axisLine = newLine(xAxisPoints);
            axisLine.set({
                x1: axisLine.x1 + 4,
                x2: axisLine.x2 - 4,
            });
            return [axisLine];
        };

        const axisY = () => {
            const [x1, y1, x2, y2] = yAxisPoints;
            // // 箭头长度
            // const h = 8 * lineWidth;
            // // 高度
            // const w = h / Math.sqrt(3);
            // const arrowUpPoints = (left = true) => {
            //     return [
            //         left ? x1 - w : x1 + w,
            //         y1 + h,
            //         x1 - offset,
            //         y1
            //     ]
            // };
            // const arrowDownPoints = (left = true) => {
            //     return [
            //         left ? x2 - w : x2 + w,
            //         y2 - h,
            //         x2 - offset,
            //         y2
            //     ]
            // };
            // const upl = arrowUpPoints(true);
            // const upr = arrowUpPoints(false);
            // const downl = arrowDownPoints(true);
            // const downr = arrowDownPoints(false);
            return [
                newLine(yAxisPoints, lineAttrs, 'vertical'),
                // newLine(upl),
                // newLine(upr),
                // newLine(downl),
                // newLine(downr),
            ];
        };

    </script>

</body>

</html>